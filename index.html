<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Dig UP!</title>
        
        <style>
            body {
                overflow-y: hidden;
                font-family: "Courier new", "Cambria";
                text-align: center;
                margin: 20px;
            }

            header {
                margin-bottom: 2px;
            }

            canvas {
                border: 1px solid black;
            }

            section {
                border: 1px dashed black;
                padding: 10px;
                height: 100%;
                text-indent: 50px;
            }

            main {
                border: 1px solid black;
                padding: 20px;
                padding-bottom: 40px;
                height: 68vh;
            }
        </style>
    </head>
    <body onmousemove="init(event); getMouseX(event); getMouseY(event);">
        <header>
            <h1>Dig UP!</h1>
            <span>Archeology-base memory game.</span>
        </header>
        <main>
            <section>
                <p id="textbox">Test Text Test Text Test Text Test Text Test Text Test Text</p>
                <canvas id="display">This element is unsupported.</canvas>
            </section>
        </main>

        <script>
            const canvas = document.getElementById("display")
            const rect = canvas.getBoundingClientRect()

            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            const tileSizeX = 20;
            const tileSizeY = 20;

            const MapSizeX = (canvas.width * scaleX) / tileSizeX;
            const MapSizeY = (canvas.height * scaleY) / tileSizeY;

            let mapArray = [];

            var getMouseX = function(e) {
                return Math.round(range((e.clientX - rect.left) * scaleX, 0, rect.width * scaleX));
            }
            var getMouseY = function(e) {
                return Math.round(range((e.clientY - rect.top) * scaleY, 0, rect.height * scaleY));
            }

            function init(e) {
                document.getElementById("textbox").innerHTML = mapGenerator(20, 0, 200, MapSizeX, MapSizeY)
                // document.getElementById("textbox").innerHTML = getMouseX(e)+", "+getMouseY(e)+" || "+scaleX+", "+scaleY;
            }

            function range(val, min, max) {
                // I created this function to control the values that will be used within my website. This is to help with numerical data controls and to allow for me to keep a "lid" on the values that will be present within my game.
                if (val > max) {
                    return max;
                } else if (val < min) {
                    return min;
                } else {
                    return val;
                }
            }

            function mapGenerator(gradient, MinV, MaxV, MaxX, MaxY) {
                var tempMultiArray = [];
                var tempArray = [];
                let x, y, r, diff;

                for (x = 0; x < MaxX; x++) {
                    for (y = 0; y < MaxY; y++) {
                        tempArray.push(MinV);
                    }
                    tempMultiArray.push(tempArray);
                    tempArray = [];
                }

                for (x = 0; x < MaxX; x++) {
                    for (y = 0; y < MaxY; y++) {
                        r = (Math.random()*2)-1;
                        diff = gradient*r;
                        // I use r as a random numeric value variable with this value I then times it by 2 and then -1 this can then provide me with a value that is either -0.9 or 0.9 which will allow for me to be able to change the value that will be applied to the diff variable. Diff is the difference that needs to be applied to the chosen tile of the array and will alalow for me to either accend or decent that tile by the current amount that is present. This allows for the terrain to gain a random but effective difference in depth. Along with this the random value that is created modifies the gradient variable that is given though the function. This is how you can customise how must the terrain can change in altitute. Gradient represents the overal height difference you would like to see in your terrain.
                        
                        tempMultiArray[x][y] = range(Math.round(tempMultiArray[x][y]+diff), MinV, MaxV);

                        /* I then after modifing the original selected tile begin to modify any tiles that are adjacent to this selected tile. I first check if there is a tile in either the positive or negative position to the main one and then do an average of the main tile and the tile that is select. After the average of those two values I then change that tile by the difference.
                        I begin by taking the value of the adjacent tile, altering by the selected difference and once I alter that I take the value from the original center tile and average both of their values together to create a slightly flatter and more progressive terrain.
                        */

                        if (x+1 < MaxX) {
                            // This is the tile that is to the right of the chosen tile and is modified in the way stated in the previous comment.
                            tempMultiArray[x+1][y] = range(Math.round(((tempMultiArray[x+1][y]+diff)+tempMultiArray[x][y])/2), MinV, MaxV);

                        }
                        if (x-1 > 0) {
                            // This is the tile that is to the left of the chosen tile and is modified in the way stated in the previous comment.
                            tempMultiArray[x-1][y] = range(Math.round(((tempMultiArray[x-1][y]+diff)+tempMultiArray[x][y])/2), MinV, MaxV);
                        }
                        if (y+1 < MaxY) {
                            // This is the tile that is to the top of the chosen tile and is modified in the way stated in the previous comment.
                            tempMultiArray[x][y+1] = range(Math.round(((tempMultiArray[x][y+1]+diff)+tempMultiArray[x][y])/2), MinV, MaxV);
                        }
                        if ( y-1 > 0) {
                            // This is the tile that is to the bottom of the chosen tile and is modified in the way stated in the previous comment.
                            tempMultiArray[x][y-1] = range(Math.round(((tempMultiArray[x][y-1]+diff)+tempMultiArray[x][y])/2), MinV, MaxV);
                        }
                    }
                }
                // Once the entire multi-array has been created and randomly altered I then return this out of the function so that it can be called and casted to an external variable.
                return tempMultiArray;
            }
        </script>
    </body>
</html>