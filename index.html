<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Dig UP!</title>
        
        <style>
            body {
                overflow-y: hidden;
                font-family: "Courier new", "Cambria";
                text-align: center;
                margin: 20px;
                min-width: 700px;
                min-height: 500px;
            }

            header {
                margin-bottom: 2px;
            }

            canvas {
                border: 1px solid black;
                width: 60vw;
                height: 40vw;
            }

            section {
                border: 1px dashed black;
                padding: 10px;
                height: 100%;
                text-indent: 50px;
            }

            main {
                border: 1px solid black;
                padding: 20px;
                padding-bottom: 40px;
                height: 68vh;
            }
        </style>
    </head>
    <body onload="init();" onmousemove="MouseMove(event);" onkeydown="KeyDown(event)" onkeyup="KeyUp()" onmousedown="MouseDown()" onmouseup="MouseUp()">
        <header>
            <h1>Dig UP!</h1>
            <span>Archeology-base memory game.</span>
        </header>
        <main>
            <section>
                <span id="name"></span>
                <span id="textbox">Test Text Test Text Test Text Test Text Test Text Test Text</span>
                <br>
                <canvas id="display">This element is unsupported.</canvas>
            </section>
        </main>

        <script>
            // These two variables are the canvas located in the HTML and also the canvases rectangular hitbox
            // I will also declare the textbox as a constant variable so I can alter its inner HTML easier.
            const canvas = document.getElementById("display")
            const rect = canvas.getBoundingClientRect()
            const textbox = document.getElementById("textbox")

            // I will create a variable called ctx which is "context" which will hold the drawn out products that are printed to the canvas. This will be needed for the draw and clear function.
            const ctx = canvas.getContext("2d");

            // Using the canvas and its hitbox I then create a scale factor of how big the actual canvas is currently being displayed at. This allows for me to change the actual size of the canvas and any following numerical data to make sure that I am using the correct data from the website that the user is using.
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            // This is just a constant value of the size of each tile that will be printed to the screen, I have also locked the total amount of tiles that will be printed using the size constants that are set to 20 whilst I am in the early development.
            const tileSizeX = 5;
            const tileSizeY = 5;
            const MapSizeX = Math.round((rect.width * scaleX) / tileSizeX);
            const MapSizeY = Math.round((rect.height * scaleY) / tileSizeY);

            // This is an initialization of the mapArray so that it can hold the numerical values in the array format.
            let mapArray = [];

            // Create an array to hold the sequence and another to hold the users inputted characters.
            let randomSequence = [];
            let usersSequence = [];

            // These are the variables that will be used during outputs from the EventHandlers and will allow for me to get a public mouse location and a keyCode of the current buttom pressed.
            let mouseX = 0;
            let mouseY = 0;
            let click = false;
            let keyCode;

            // Add an array initializer to create the biome array needed to produce the values needed when rendering the terrain.
            let biomeType = [];

            // Set a value for the point-of-interests size when its displayed to the user.
            const nodeSizeX = 20;
            const nodeSizeY = 20;

            // Create an array to hold the position location of each of the nodes or points of interest that are present within a map.
            let nodePosArray = [];

            // Create an array to hold the positions of the users attempts on digging in the terrain. Also a variable used to hold the users attempts within the terrain. This can be effected and increased by the upgrades later.            
            let usersPosArray = [];
            let usersAttempts = 0;

            // A time variable to count up or down the length of the time that the points of interests that are displayed. Another variable that will time the display of the random sequence.
            let nodeDisplayTime;
            let sequenceDisplayTime;

            // Let a variable be equal to 0 to hold the value of which one is selected.
            let selectedMenuOption = 0;
            let selectedOptionDifference = 0;
            // the chosen menu option will take the value of the selected menu option when the user presses a button like enter or space or uses the mouse.
            let chosenMenuOption = -1;

            // This is a container with all of the possible gameStates that can be assigned to gameState, I use a numerical value for the state variable and have this function to give a name to what that numerical value stands for. I will then also organise these different numbers into groups depending on what they may include or do. Example, tutorial will have several messages that can be displayed to the screen.
            const gameStates = {
                WELCOME: 0,
                TUTORIAL: {
                    MESSAGE_ONE: 1,
                    MESSAGE_TWO: 2,
                    MESSAGE_THREE: 3,
                    MESSAGE_FOUR: 4,
                    MESSAGE_FIVE: 5,
                    MESSAGE_SIX: 6,
                    MESSAGE_SEVEN: 7,
                    MESSAGE_EIGHT: 8
                },
                MAIN_MENU: 9,
                BIOME_MENU: 10,
                MUSEUM_MENU: 11,
                INVENTORY_SCREEN: 12,
                UPGRADE_MENU: 13,
                RENDER_TERRAIN: 14,
                RENDER_NODES: 15,
                BEGIN_GAME: 16,
                DISPLAY_DIGGOUTS: 17,
                BEGIN_SEQUENCE: 18,
                REPEAT_SEQUENCE: 19
            };

            // A container for the current state on which the game is at so that the script knows what to do depending on the state.
            let gameState

            const textboxMessages = ["Hello", "Who", "Are", "You", "Hello", "Who", "Are", "You", "Hello", "Who", "Are", "You", "Hello", "Who", "Are", "You", "Hello", "Who", "Are", "You", "Hello", "Who", "Are", "You"]
            const MenuOptions = [["World Map", "Museum", "Inventory", "Upgrade"],["Plains", "Desert", "Forest", "Swamp"], ["Process"]]

            function init() {
                // This function will be used when the page loads and will start or "(init)ialize" the rest of the needed programs.
                setInterval(main, 20);

                gameState = 9;
                
                // setGameState(1);
                // setInterval(draw, 20);
            }

            function MenuPrintout(array, selectedItem) {
                // This will be a basic function that will create an array and be given a chosen item and return the string print out of the list with a selected item in bold.
                let i;
                let temp_string = "";
                for (i = 0; i < array.length; i++) {
                    if (i == selectedItem) {
                        temp_string = temp_string+"<br><b>"+array[i]+"</b>"
                    } else {
                        temp_string = temp_string+"<br>"+array[i]
                    }
                }
                return temp_string
            }

            function main() {
                /* This is my main function within my script, this will make sure that the parts of the script that are needed will always run. */
                clear();

                textbox.innerHTML = textboxMessages[gameState]

                if (keyCode > 0) {
                    if (keyCode == 87) {
                        selectedOptionDifference = -1;
                    }
                    if (keyCode == 83) {
                        selectedOptionDifference = 1;
                    }
                    if (keyCode == 13 || keyCode == 32) {
                        chosenMenuOption = selectedMenuOption
                    }
                    keyCode = 0
                }

                if (click) {
                    if (gameState == gameStates.BEGIN_GAME && usersAttempts > 0) {
                        usersPosArray.push(mouseX);
                        usersPosArray.push(mouseY);
                        usersAttempts -= 1
                    }
                    click = false;
                }

                if (selectedOptionDifference != 0) {
                    selectedMenuOption = range(selectedMenuOption+selectedOptionDifference, 0, MenuOptions[0].length-1);
                    selectedOptionDifference = 0;
                }

                if (gameState == gameStates.MAIN_MENU) {
                    textbox.innerHTML = textbox.innerHTML+MenuPrintout(MenuOptions[0], selectedMenuOption);
                    if (chosenMenuOption != -1) {
                        gameState = gameState+chosenMenuOption+1
                        chosenMenuOption = -1
                    }
                }

                if (gameState == gameStates.BIOME_MENU) {
                    // This will check if the gameState is the biome menu and will display the options on the terrain. It will then print out the menu, and then check if the player has selected or chosen an option and change the game state to RENDER TERRAIN, once changed will obtain data on the terrain that has been chosen.
                    textbox.innerHTML = textbox.innerHTML+MenuPrintout(MenuOptions[1], selectedMenuOption);
                    if (chosenMenuOption != -1) {
                        gameState = 14; // GameState change to RENDER TERRAIN
                        biomeType = getBiomeVal(chosenMenuOption);
                        nodeDisplayTime = 100
                        usersAttempts = 3
                    }
                }

                if (gameState == gameStates.RENDER_TERRAIN) {
                    // Generate the terrain when a biome is chosen, and change the game state to a state to explain the terrain has been built. Also generate a series of Positions for the nodes.
                    mapArray = mapGenerator(biomeType[0], biomeType[1], biomeType[2], MapSizeX, MapSizeY);
                    nodePosArray = nodeGenerator((usersAttempts*2));
                    gameState = 15 // gameState is equal to display nodes
                }

                if (nodeDisplayTime > 0) {
                    nodeDisplayTime -= 1
                } else if (nodeDisplayTime == 0) {
                    gameState = 16 // GameState is equal to begin game.
                }

                if (gameState == gameStates.BEGIN_GAME && usersAttempts == 0) {
                    gameState = 17;
                }

                if (usersAttempts > 0) {
                    textbox.innerHTML = textbox.innerHTML+"<br>You have got "+usersAttempts+" attempts remaining.";
                }

                if (mapArray != []) {
                    // This will render to the canvas if the mapArray contains some mappable data.
                    mapRender(mapArray, biomeType[3], MapSizeX, MapSizeY, tileSizeX, tileSizeY);
                }

                if (gameState == gameStates.RENDER_NODES) {
                    // This will render the nodes until the gamemode is changed.
                    nodeRender(nodePosArray);
                }

                if (gameState == gameStates.DISPLAY_DIGGOUTS || gameState == gameStates.BEGIN_SEQUENCE) {
                    // Create a function that will display the locations the user has selected.
                    nodeRender(usersPosArray);
                    if (gameState == gameStates.DISPLAY_DIGGOUTS) {
                        gameState = gameStates.BEGIN_SEQUENCE;
                    }
                }

                if (randomSequence.length == 0 && gameState == gameStates.BEGIN_SEQUENCE) {
                    randomSequence = sequenceGenerator(["w", "a", "s", "d"], 5)
                    sequenceDisplayTime = 100
                } else if (sequenceDisplayTime > 0) {
                    textbox.innerHTML = textbox.innerHTML+"<br>"+randomSequence
                    sequenceDisplayTime -= 1
                } else if (sequenceDisplayTime == 0) {
                    gameState = 19
                } else if (usersSequence.length == randomSequence.length) {
                    // add a function to test if both variables are the same.
                }
            }

            function sequenceGenerator(array, len) {
                // This will take an array of characters that will be used to create a random array with a definable length. This function will be used for two of my mini-games but will use two different sets of characters for the both mini-games.
                let i, r;
                let temp_array = [];
                for (i = 0; i < len; i++) {
                    r = Math.random();
                    // Create a variable to hold a random int, use that int to then chose a random number from an array, using the arrays length * by random then rounded to the nearest whole number, then -1 to give an actual position in the array. Add that character to a temp array and once anotehr characters are added to the array, return the array.
                    temp_array.push(array[Math.round(r*(array.length-1))]);
                }
                return temp_array;
            }

            function nodeGenerator(num) {
                // This function will create a series of random position that can easily be displayed on the canvas temparerily for the user. It returns the values which is a long singular array of x,y,x,y,x,y,x,y which will be interpreted as this structure by a nodeRender function.
                let i, x, y;
                let temp_pos = []
                for (i = 0; temp_pos.length != num*2; i = i+2) {
                    x = range(Math.round(Math.random()*rect.width*scaleX), nodeSizeX, rect.width*scaleY-nodeSizeX);
                    y = range(Math.round(Math.random()*rect.height*scaleY), nodeSizeY, rect.height*scaleY-nodeSizeY);
                    if (temp_pos.indexOf(x) == -1 && temp_pos.indexOf(y) == -1) {
                        temp_pos.push(x);
                        temp_pos.push(y);
                    }
                }
                return temp_pos;
            }

            function nodeRender(array) {
                // This function is used to generate the location of the nodes that have been created on the terrain. This shows the points as locations prepresented on the canvas. Taking the array in a singular array and in the way of x,y,x,y layout.
                let i;
                for (i = 0; i < array.length; i = i+2) {
                    draw("hsl(0, 0%, 0%)", array[i]-(nodeSizeX/2), array[i+1]-(nodeSizeY/2), nodeSizeX, nodeSizeY);
                }
            }

            function getBiomeVal(val) {
                // Returns the corresponding values depending on what the users has chosen for the terrain type. This will return the gradient, minV, maxV and a color set up, this is the beginning of a hsl() value including the hue and saturation and the lightness will be created externally by the value set up by the mapGeneration function. This lets me set up a color variation in the terrain.
                if (val == 0) {
                    return [5, 40, 75, "hsl(20, 40%, "]
                }
            }

            function MouseMove(e) {
                // This function will cast out the users position relative to the canvas. This is done by taking the users X or Y and then finding the location of the canvas and the rectangular hitbox. This is then rounded afterwards.
                mouseX = Math.round(range((e.clientX - rect.left) * scaleX, 0, rect.width * scaleX));
                mouseY = Math.round(range((e.clientY - rect.top) * scaleY, 0, rect.height * scaleY));
            }

            function KeyDown(e) {
                // Will set the keyCode variable with the code of a key that is down.
                keyCode = e.keyCode;
            }

            function MouseDown() {
                // Will set the click variable to true to show that the mouse button is down.
                click = true;
            }

            function range(val, min, max) {
                // I created this function to control the values that will be used within my website. This is to help with numerical data controls and to allow for me to keep a "lid" on the values that will be present within my game.
                if (val > max) {
                    return max;
                } else if (val < min) {
                    return min;
                } else {
                    return val;
                }
            }

            function mapGenerator(gradient, MinV, MaxV, MaxX, MaxY) {
                /* This function is used to create and generate a random two dimensional array which takes specific conditions.

                gradient - this is the amount general progression of the values on the multi-array this is how the value will begin to alter.
                MinV and MaxV - these are just restrictive containers for the values to remain inbetween a range that can be external altered or changed.
                MaxX and MaxY - this is how long you would like to make the array, this is if you want to make the map bigger or smaller depending on these two values. They define how long the for loops will run for. */
                let tempMultiArray = [];
                let tempArray = [];
                let x, y, r, diff;

                for (x = 0; x < MaxX; x++) {
                    for (y = 0; y < MaxY; y++) {
                        tempArray.push(MinV);
                    }
                    tempMultiArray.push(tempArray);
                    tempArray = [];
                }

                for (x = 0; x < MaxX; x++) {
                    for (y = 0; y < MaxY; y++) {
                        r = (Math.random()*2)-1;
                        diff = gradient*r;
                        // I use r as a random numeric value variable with this value I then times it by 2 and then -1 this can then provide me with a value that is either -0.9 or 0.9 which will allow for me to be able to change the value that will be applied to the diff variable. Diff is the difference that needs to be applied to the chosen tile of the array and will alalow for me to either accend or decent that tile by the current amount that is present. This allows for the terrain to gain a random but effective difference in depth. Along with this the random value that is created modifies the gradient variable that is given though the function. This is how you can customise how must the terrain can change in altitute. Gradient represents the overal height difference you would like to see in your terrain.
                        
                        tempMultiArray[x][y] = range(Math.round(tempMultiArray[x][y]+diff), MinV, MaxV);

                        /* I then after modifing the original selected tile begin to modify any tiles that are adjacent to this selected tile. I first check if there is a tile in either the positive or negative position to the main one and then do an average of the main tile and the tile that is select. After the average of those two values I then change that tile by the difference.
                        I begin by taking the value of the adjacent tile, altering by the selected difference and once I alter that I take the value from the original center tile and average both of their values together to create a slightly flatter and more progressive terrain.
                        */

                        if (x+1 < MaxX) {
                            // This is the tile that is to the right of the chosen tile and is modified in the way stated in the previous comment.
                            tempMultiArray[x+1][y] = range(Math.round(((tempMultiArray[x+1][y]+diff)+tempMultiArray[x][y])/2), MinV, MaxV);

                        }
                        if (x-1 > 0) {
                            // This is the tile that is to the left of the chosen tile and is modified in the way stated in the previous comment.
                            tempMultiArray[x-1][y] = range(Math.round(((tempMultiArray[x-1][y]+diff)+tempMultiArray[x][y])/2), MinV, MaxV);
                        }
                        if (y+1 < MaxY) {
                            // This is the tile that is to the top of the chosen tile and is modified in the way stated in the previous comment.
                            tempMultiArray[x][y+1] = range(Math.round(((tempMultiArray[x][y+1]+diff)+tempMultiArray[x][y])/2), MinV, MaxV);
                        }
                        if (y-1 > 0) {
                            // This is the tile that is to the bottom of the chosen tile and is modified in the way stated in the previous comment.
                            tempMultiArray[x][y-1] = range(Math.round(((tempMultiArray[x][y-1]+diff)+tempMultiArray[x][y])/2), MinV, MaxV);
                        }
                    }
                }
                // Once the entire multi-array has been created and randomly altered I then return this out of the function so that it can be called and casted to an external variable.
                return tempMultiArray;
            }

            function mapRender(multi_array, biomeColor, MaxX, MaxY, SizeX, SizeY) {
                let x, y;
                for (x = 0; x < MaxX; x++) {
                    for (y = 0; y < MaxY; y++) {
                        draw((biomeColor+multi_array[x][y]+"%)"), x*SizeX, y*SizeY, SizeX, SizeY)
                    }
                }
            }

            function draw(color, x, y, size_x, size_y) {
                /* This is the draw function which only has a sole purpose to print out the tiles of the terrain that has been randomly generated. I will create a render function for the terrain which will widely use this function.

                color - it will be the color value of the tile. It will be using the hsl() color function from css to allow for tiles to gain a form of difference in "lightness" to display to the user a sense of depth.
                x and y - location of the tiles that are being printed.
                size_x and size_y are the size of the tiles that will be printed. */
                ctx.beginPath();

                ctx.fillStyle = color;
                ctx.fillRect(x, y, size_x, size_y);

                ctx.stroke();
            }

            function clear() {
                // This function will clear the canvas when needed. This will allow for me to clear and reprint to the canvas if needed.
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }
        </script>
    </body>
</html>