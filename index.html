<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Dig UP!</title>
        
        <style>
            body {
                overflow-y: hidden;
                font-family: "Courier new", "Cambria";
                text-align: center;
                margin: 20px;
            }

            header {
                margin-bottom: 2px;
            }

            canvas {
                border: 1px solid black;
            }

            section {
                border: 1px dashed black;
                padding: 10px;
                height: 100%;
                text-indent: 50px;
            }

            main {
                border: 1px solid black;
                padding: 20px;
                padding-bottom: 40px;
                height: 68vh;
            }
        </style>
    </head>
    <body onmousemove="MouseMove(event); init();" onkeypress="KeyPress(event)">
        <header>
            <h1>Dig UP!</h1>
            <span>Archeology-base memory game.</span>
        </header>
        <main>
            <section>
                <p id="textbox">Test Text Test Text Test Text Test Text Test Text Test Text</p>
                <canvas id="display">This element is unsupported.</canvas>
            </section>
        </main>

        <script>
            // These two variables are the canvas located in the HTML and also the canvases rectangular hitbox
            const canvas = document.getElementById("display")
            const rect = canvas.getBoundingClientRect()

            // Using the canvas and its hitbox I then create a scale factor of how big the actual canvas is currently being displayed at. This allows for me to change the actual size of the canvas and any following numerical data to make sure that I am using the correct data from the website that the user is using.
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            // This is just a constant value of the size of each tile that will be printed to the screen, I have also locked the total amount of tiles that will be printed using the size constants that are set to 20 whilst I am in the early development.
            const tileSizeX = 20;
            const tileSizeY = 20;
            const MapSizeX = (canvas.width * scaleX) / tileSizeX;
            const MapSizeY = (canvas.height * scaleY) / tileSizeY;

            // This is an initialization of the mapArray so that it can hold the numerical values in the array format.
            let mapArray = [];

            // These are the variables that will be used during outputs from the EventHandlers and will allow for me to get a public mouse location and a keyCode of the current buttom pressed.
            let mouseX = 0;
            let mouseY = 0;
            let keyCode;

            function init() {
                // This function will be used when the page loads and will start or "(init)ialize" the rest of the needed programs.
                document.getElementById("textbox").innerHTML = keyCode
                // document.getElementById("textbox").innerHTML = getMouseX(e)+", "+getMouseY(e)+" || "+scaleX+", "+scaleY;
            }

            function MouseMove(e) {
                // This function will cast out the users position relative to the canvas. This is done by taking the users X or Y and then finding the location of the canvas and the rectangular hitbox. This is then rounded afterwards.
                mouseX = Math.round(range((e.clientX - rect.left) * scaleX, 0, rect.width * scaleX));
                mouseY = Math.round(range((e.clientY - rect.top) * scaleY, 0, rect.height * scaleY));
            }

            function KeyPress(e) {
                // This function casts out the key that is pressed at one current time.
                keyCode = e.keyCode;
            }

            function range(val, min, max) {
                // I created this function to control the values that will be used within my website. This is to help with numerical data controls and to allow for me to keep a "lid" on the values that will be present within my game.
                if (val > max) {
                    return max;
                } else if (val < min) {
                    return min;
                } else {
                    return val;
                }
            }

            function mapGenerator(gradient, MinV, MaxV, MaxX, MaxY) {
                var tempMultiArray = [];
                var tempArray = [];
                let x, y, r, diff;

                for (x = 0; x < MaxX; x++) {
                    for (y = 0; y < MaxY; y++) {
                        tempArray.push(MinV);
                    }
                    tempMultiArray.push(tempArray);
                    tempArray = [];
                }

                for (x = 0; x < MaxX; x++) {
                    for (y = 0; y < MaxY; y++) {
                        r = (Math.random()*2)-1;
                        diff = gradient*r;
                        // I use r as a random numeric value variable with this value I then times it by 2 and then -1 this can then provide me with a value that is either -0.9 or 0.9 which will allow for me to be able to change the value that will be applied to the diff variable. Diff is the difference that needs to be applied to the chosen tile of the array and will alalow for me to either accend or decent that tile by the current amount that is present. This allows for the terrain to gain a random but effective difference in depth. Along with this the random value that is created modifies the gradient variable that is given though the function. This is how you can customise how must the terrain can change in altitute. Gradient represents the overal height difference you would like to see in your terrain.
                        
                        tempMultiArray[x][y] = range(Math.round(tempMultiArray[x][y]+diff), MinV, MaxV);

                        /* I then after modifing the original selected tile begin to modify any tiles that are adjacent to this selected tile. I first check if there is a tile in either the positive or negative position to the main one and then do an average of the main tile and the tile that is select. After the average of those two values I then change that tile by the difference.
                        I begin by taking the value of the adjacent tile, altering by the selected difference and once I alter that I take the value from the original center tile and average both of their values together to create a slightly flatter and more progressive terrain.
                        */

                        if (x+1 < MaxX) {
                            // This is the tile that is to the right of the chosen tile and is modified in the way stated in the previous comment.
                            tempMultiArray[x+1][y] = range(Math.round(((tempMultiArray[x+1][y]+diff)+tempMultiArray[x][y])/2), MinV, MaxV);

                        }
                        if (x-1 > 0) {
                            // This is the tile that is to the left of the chosen tile and is modified in the way stated in the previous comment.
                            tempMultiArray[x-1][y] = range(Math.round(((tempMultiArray[x-1][y]+diff)+tempMultiArray[x][y])/2), MinV, MaxV);
                        }
                        if (y+1 < MaxY) {
                            // This is the tile that is to the top of the chosen tile and is modified in the way stated in the previous comment.
                            tempMultiArray[x][y+1] = range(Math.round(((tempMultiArray[x][y+1]+diff)+tempMultiArray[x][y])/2), MinV, MaxV);
                        }
                        if (y-1 > 0) {
                            // This is the tile that is to the bottom of the chosen tile and is modified in the way stated in the previous comment.
                            tempMultiArray[x][y-1] = range(Math.round(((tempMultiArray[x][y-1]+diff)+tempMultiArray[x][y])/2), MinV, MaxV);
                        }
                    }
                }
                // Once the entire multi-array has been created and randomly altered I then return this out of the function so that it can be called and casted to an external variable.
                return tempMultiArray;
            }
        </script>
    </body>
</html>